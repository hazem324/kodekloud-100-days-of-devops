# Create a Docker File

As per recent requirements shared by the Nautilus application development team, they need custom images created for one of their projects. Several of the initial testing requirements have already been shared with the DevOps team.

Therefore, a Docker file has been created at:

```
/opt/docker/Dockerfile
```

(on **App Server 2** in **Stratos DC**) to build a custom Apache image.

---

## Steps

### 1. Connect to App Server 2

   ```bash
   ssh tony@stapp01
   ```

### 2. Switch to root user

   ```bash
   sudo -i
   ```

### 3. Navigate to the Docker working directory

   ```bash
   cd /opt/docker
   ```

### 4. Create and edit the Dockerfile

   ```bash
   vi Dockerfile
   ```

### 5. Add Docker instructions

   * Define `ubuntu:24.04` as the base image
   * Install `apache2` using `apt`
   * Update Apache to listen on the required port
   * Expose the configured port
   * Run Apache in foreground mode

[Dockerfile](../files/Dockerfile)

### 6. Save and exit the file

   * Press `ESC`
   * Type `:wq`
   * Press `Enter`

---

## Good to Know

### Dockerfile Fundamentals

* **Purpose**: A Dockerfile defines the steps needed to build a Docker image
* **Automation**: Ensures repeatable and consistent image creation
* **Layered Build**: Each instruction creates a new image layer
* **Caching**: Docker reuses unchanged layers to speed up builds

---

### Common Dockerfile Instructions Used

* **FROM** – Defines the base image
* **ENV** – Sets environment variables for build-time behavior
* **RUN** – Executes commands during image build
* **EXPOSE** – Documents the port used by the container
* **CMD** – Defines the default command when the container starts

---

### Apache in Docker

* **Port Configuration**: Apache listens on a custom port instead of default 80
* **Foreground Mode**: Apache must run in the foreground to keep the container running
* **Minimal Changes**: Only required configuration is adjusted to meet task constraints

---

### Best Practices Highlighted

* Combine commands to reduce image layers
* Clean package cache to reduce image size
* Avoid unnecessary configuration changes
* Keep container processes simple and predictable