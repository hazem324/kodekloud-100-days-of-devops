# Deploy Iron Gallery App on Kubernetes

The Nautilus DevOps team customized the **Iron Gallery application** and prepared it for deployment on a Kubernetes cluster.

This deployment includes:

* A frontend application (Iron Gallery)
* A MariaDB database (Iron DB)
* Internal and external services
* Ephemeral storage using `emptyDir`

---

## Steps

### 1. Create the Namespace

```bash
kubectl create namespace iron-namespace-devops
kubectl get namespaces
```

Add the following content: [`namespaces file`](../files/k8s_iron_gallery_namespace_d63.yml)

### 2. Create Iron Gallery Deployment File

Create a file named:

```bash
iron-gallery-deployment.yaml
```

Add the following content: [`iron-gallery-deployment file`](../files/k8s_iron_gallery_deploy_d63.yml)

Apply the configuration:

```bash
kubectl apply -f iron-gallery-stack.yaml
```

### 3. Create Iron DB Deployment File

Create a file named:

```bash
iron-db-deployment.yaml
```

Add the following content: [`iron-db-deployment file`](../files/k8s_iron_db_deployment_d63.yml)

Apply the configuration:

```bash
kubectl apply -f iron-db-deployment.yaml
```

### 4. Create Iron Gallery Service File

Create a file named:

```bash
iron-gallery-service.yaml
```

Add the following content: [`iron-gallery-service file`](../files/k8s_iron_gallery_service_d63.yml)

Apply the configuration:

```bash
kubectl apply -f iron-gallery-service.yaml
```

### 5. Create Iron DB Service File

Create a file named:

```bash
iron-db-service.yaml
```

Add the following content: [`iron-db-service file`](../files/k8s_iron_db_service_d63.yml)

Apply the configuration:

```bash
kubectl apply -f iron-db-service.yaml
```

### 6. Verify Deployment

Check namespace resources:

```bash
kubectl get all -n iron-namespace-devops
```

Check specifically:

```bash
kubectl get deployments -n iron-namespace-devops
kubectl get pods -n iron-namespace-devops
kubectl get svc -n iron-namespace-devops
```

---

# Good to Know 

##  Namespace Isolation Strategy

Namespaces provide:

* Logical separation between environments (dev, staging, prod)
* Resource scoping
* RBAC control boundaries
* Cleaner resource management

In real-world projects, each team or environment typically uses its own namespace.


##  Stateless vs Stateful Workloads

* **Iron Gallery (Frontend)** ‚Üí Stateless
* **Iron DB (MariaDB)** ‚Üí Stateful

Because we used `emptyDir`, the database data:

* Lives inside the pod
* Is deleted if the pod restarts

For production:

* Use PersistentVolumes (PV)
* Use PersistentVolumeClaims (PVC)
* Prefer StatefulSets for databases

---

##  Why We Used NodePort

`NodePort` exposes the service externally via:

```
<Node-IP>:32678
```

Better production alternatives:

* Ingress Controller
* LoadBalancer service type
* API Gateway


##  Resource Limits

We defined:

```yaml
memory: 100Mi
cpu: 50m
```

This prevents:

* Resource starvation
* Noisy neighbor problems
* Cluster instability

Always define resource limits in production.


##  Environment Variables for Database

We configured:

* `MYSQL_DATABASE`
* `MYSQL_ROOT_PASSWORD`
* `MYSQL_USER`
* `MYSQL_PASSWORD`

‚ö†Ô∏è In production, never store passwords directly in YAML.

Instead use:

* Kubernetes Secrets
* External secret managers (Vault, AWS Secrets Manager)


##  Kubernetes Architecture Awareness

This project demonstrates:

* Multi-tier application deployment
* Service-to-pod communication via labels
* Service abstraction over pods
* Volume mounting
* Resource management

You are essentially practicing real-world DevOps architecture patterns here üöÄ


##  What Can Be Improved?

To make this production-ready:

* Replace `emptyDir` with PVC
* Move DB credentials to Secrets
* Add readiness & liveness probes
* Add Horizontal Pod Autoscaler (HPA)
* Deploy via CI/CD pipeline (Jenkins or GitHub Actions)
