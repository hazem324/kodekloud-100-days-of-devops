# Execute Rolling Updates in Kubernetes

An existing application is deployed in a Kubernetes cluster using the **nginx web server**.
The development team released an updated container image: **`nginx:1.17`**.

Your task is to:

* Perform a **rolling update** on the deployment named `nginx-deployment`
* Upgrade the container image to **nginx:1.17**
* Ensure all pods are running successfully after the update

> Note: The `kubectl` tool on `jump_host` is already configured to access the Kubernetes cluster.

---

## Steps

### 1. Check the Current Deployment

```sh
kubectl get deployment nginx-deployment
```

Output:

```text
NAME               READY   UP-TO-DATE   AVAILABLE   AGE
nginx-deployment   3/3     3            3           2m40s
```

This confirms:

* Deployment exists
* 3 replicas are running
* All replicas are available

### 2. Inspect Deployment Configuration

```sh
kubectl describe deployment nginx-deployment
```

Important details identified:

* Strategy: **RollingUpdate**
* Container Name: `nginx-container`
* Current Image: `nginx:1.16`
* Replicas: 3

### 3. Update the Image (Rolling Update)

Since the container name is `nginx-container`, the correct command is:

```sh
kubectl set image deployment/nginx-deployment nginx-container=nginx:1.17
```

Output:

```text
deployment.apps/nginx-deployment image updated
```

This automatically triggers a rolling update.

---

### 4. Monitor Rollout Progress

```sh
kubectl rollout status deployment/nginx-deployment
```

Output:

```text
deployment "nginx-deployment" successfully rolled out
```

This confirms the update completed successfully.

---

### 5. Verify Pods After Update

```sh
kubectl get pods
```

Example Output:

```text
NAME                                READY   STATUS    RESTARTS   AGE
nginx-deployment-5dd558cf95-g8p29   1/1     Running   0          36s
nginx-deployment-5dd558cf95-qrg8h   1/1     Running   0          38s
nginx-deployment-5dd558cf95-rzbqk   1/1     Running   0          45s
```

---

### 6. Check Deployment Revision History

```sh
kubectl rollout history deployment/nginx-deployment
```

Output:

```text
REVISION  CHANGE-CAUSE
1         <none>
2         <none>
```

A new revision confirms the update was applied.

---

# Good to Know 

##  Rolling Updates in Kubernetes 

A **Rolling Update** is the default deployment strategy in Kubernetes. It allows you to update your application **without downtime** by gradually replacing old pods with new ones.

### How It Works Internally

When you update a Deployment (for example changing the image):

1. Kubernetes creates a **new ReplicaSet**
2. New pods are created using the updated specification
3. Old pods are terminated gradually
4. Traffic shifts automatically to Ready pods
5. Once all new pods are running, the rollout completes

This ensures the application remains available during the entire process.

---

### Key Characteristics

 **Zero Downtime :** Pods are replaced in a controlled manner. Kubernetes never stops all replicas at once (unless configured to do so).

 **Gradual Replacement :** Pods are updated incrementally based on:

* `maxSurge`
* `maxUnavailable`

**Health-Based Progression :** If a new pod fails readiness checks, the rollout pauses automatically.

 **Versioned Revisions :** Each update creates a new **Deployment revision**, enabling rollback.

---

##  Rollback (Rolling Back / Roll Down)

A rollback restores the Deployment to a previous working revision.

### When Rollback Happens

* Manual execution (`kubectl rollout undo`)
* Failed rollout detected by the user
* Application instability after update

### What Happens During Rollback

1. Kubernetes switches to the previous ReplicaSet
2. New pods are created using the old configuration
3. Faulty pods are terminated
4. Service stabilizes using last known working version

Rollback is fast because old ReplicaSets are retained automatically.

---

##  Update Strategies

###  RollingUpdate (Default)

* Replaces pods gradually
* Maintains service availability
* Controlled using `maxSurge` and `maxUnavailable`

###  Recreate

* Terminates all old pods first
* Then creates new pods
* Causes downtime
* Used when versions cannot run simultaneously

---

##  Understanding maxSurge & maxUnavailable

These parameters control update speed and availability.

 **maxUnavailable :** Maximum number of pods that can be unavailable during update.

Example:

```
Replicas: 4
maxUnavailable: 1
```

At least 3 pods must stay running.

---

**maxSurge :** Maximum extra pods allowed above desired replicas during update.

Example:

```
Replicas: 4
maxSurge: 1
```

Kubernetes can temporarily run 5 pods during update.

---

##  What Happens Behind the Scenes

During a rolling update:

* A new ReplicaSet is created
* Pods get a new `pod-template-hash`
* Old ReplicaSet scales down gradually
* New ReplicaSet scales up gradually
* Deployment controller manages the entire lifecycle

You can observe this using:

```sh
kubectl get rs
```

---

#  Rollout & Rollback Commands

##  Update Image

```sh
kubectl set image deployment/<deployment-name> <container-name>=<image>:<tag>
```

---

##  Monitor Rollout

```sh
kubectl rollout status deployment/<deployment-name>
```

---

##  View Revision History

```sh
kubectl rollout history deployment/<deployment-name>
```

---

##  Rollback to Previous Revision

```sh
kubectl rollout undo deployment/<deployment-name>
```

Rollback to specific revision:

```sh
kubectl rollout undo deployment/<deployment-name> --to-revision=<number>
```

---

##  Pause and Resume Rollout

Pause:

```sh
kubectl rollout pause deployment/<deployment-name>
```

Resume:

```sh
kubectl rollout resume deployment/<deployment-name>
```

---

##  Scale During or After Update

```sh
kubectl scale deployment/<deployment-name> --replicas=<number>
```

---

#  Best Practices for Production

###  Configure Probes

* Use **readinessProbe** to control traffic routing
* Use **livenessProbe** for container health
* Use **startupProbe** for slow-starting apps

---

###  Set Resource Requests & Limits

Ensure enough CPU and memory are available for surge pods.

---

###  Test Before Production

Always validate images in staging before rolling to production.

---

###  Monitor During Rollout

Watch events and pod health:

```sh
kubectl get pods -w
kubectl get events
```